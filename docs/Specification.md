# Khaos.Metrics â€“ Final Design Specification (v1)## 1. ScopeKhaos.Metrics is a .NET library that:* Measures **frequency** and **latency** of logical operations.* Stores metrics in **bounded**, in-memory ring buffers.* Provides **event hooks** (rules) for slow/hot operations.* Optionally exposes metrics via ASP.NET endpoints (explicit opt-in).* Uses a **global time mode** (UTC or Local) decided at startup.This document defines:* Configuration defaults & limits (exact values).* Supported runtimes & dependencies.* Event sink dispatch behavior.* Snapshot shape, immutability, and serialization assumptions.* CPU timing approach and acceptable overhead.* Testing & benchmark expectations.Everything below is intended to remove ambiguity.---## 2. Target Runtime & Dependencies### 2.1 Target Frameworks* **Khaos.Metrics.Core**  * Target: `net8.0`* **Khaos.Metrics.AspNet**  * Target: `net8.0`* Optional future packages (e.g. OpenTelemetry integration) also target `net8.0`.No multi-targeting in v1.### 2.2 Dependencies* **Core**  * Only `System.*` assemblies (BCL).  * **No** direct dependency on:    * ASP.NET    * System.Diagnostics.Metrics    * OpenTelemetry    * Any third-party packages* **Khaos.Metrics.AspNet**  * Depends on ASP.NET Core shared framework (`Microsoft.AspNetCore.App`).* **Optional integrations** (separate packages, not part of v1 core):  * `Khaos.Metrics.OpenTelemetry` MAY depend on:    * `OpenTelemetry`    * `OpenTelemetry.Metrics`    * Potentially `System.Diagnostics.Metrics`* **Tests/Benchmarks**  * May use:    * xUnit/NUnit    * `BenchmarkDotNet`  * These are **test-only**; they MUST NOT be referenced from runtime packages.---## 3. Configuration Options â€“ Defaults & LimitsAll configuration is via `MonitoringOptions`. This section defines concrete defaults and limits.### 3.1 Time Mode (UTC vs Local)```csharppublic enum MonitoringTimeMode{    Utc,    Local}```In `MonitoringOptions`:* `TimeMode` **default**: `MonitoringTimeMode.Utc`* In your environment, you will set `TimeMode = MonitoringTimeMode.Local` once at startup.All timestamps exposed via public APIs (snapshots, events) MUST:* Use `DateTimeOffset`, and* Be derived from `TimeMode` (either `DateTimeOffset.UtcNow` or `DateTimeOffset.Now`) via `ISystemClock`.Internal timing MUST use `Stopwatch.GetTimestamp()` (time-zone independent).### 3.2 Buckets & Windows`MonitoringOptions` MUST expose:```csharppublic int HotBucketCount { get; set; }public int HotBucketSeconds { get; set; }public int WarmBucketCount { get; set; }public int WarmBucketMinutes { get; set; }public int ColdBucketCount { get; set; }public int ColdBucketHours { get; set; }```**Default values:*** `HotBucketCount = 120`* `HotBucketSeconds = 1`  * ~2 minutes of 1-second resolution* `WarmBucketCount = 60`* `WarmBucketMinutes = 1`  * ~1 hour of 1-minute resolution* `ColdBucketCount = 24`* `ColdBucketHours = 1`  * ~24 hours of 1-hour resolution**Constraints:*** All counts MUST be > 0.* All durations MUST be > 0.* Buckets MUST be implemented as fixed-size ring buffers; NO dynamic growth.### 3.3 Sampling```csharppublic int SamplingRate { get; set; }```**Default:*** `SamplingRate = 1` (every call fully measured & evented)**Behavior:*** A per-operation or per-engine counter:  * If `SamplingRate <= 1` â†’ measure every call.  * If `SamplingRate > 1`:    * Always increment total counters.    * Only perform full timing/event processing when `counter % SamplingRate == 0`.* Sampling MUST NOT affect `TotalCount` and `TotalFailures`; it only affects â€œdetailedâ€ timing and events.### 3.4 CPU Measurement```csharppublic bool EnableCpuMeasurement { get; set; }public int CpuSampleIntervalSeconds { get; set; }public int CpuSampleHistoryCount { get; set; }```**Defaults:*** `EnableCpuMeasurement = false`* `CpuSampleIntervalSeconds = 1`* `CpuSampleHistoryCount = 120` (last 2 minutes of CPU % samples)**Behavior (v1):*** If disabled: CPU-related fields in snapshots/events MUST be `null` or 0 as appropriate.* If enabled:  * A background sampler MUST:    * Every `CpuSampleIntervalSeconds` seconds:      * Call `Process.GetCurrentProcess().TotalProcessorTime`.      * Compute CPU % over the interval using:        * Delta of `TotalProcessorTime`        * Delta of wall-clock time        * Number of logical processors (`Environment.ProcessorCount`)      * Store CPU % in a ring buffer of length `CpuSampleHistoryCount`.  * `OperationCompletedContext.ProcessCpuPercent` MUST contain the latest sample (or `null` if not yet available).Per-operation CPU time MUST **not** be computed in v1.### 3.5 Operation Count & Overflow Policy```csharppublic int MaxOperationCount { get; set; }public OperationOverflowPolicy OverflowPolicy { get; set; }public enum OperationOverflowPolicy{    DropNew    // future extension: DropLeastRecentlyUsed etc.}```**Defaults:*** `MaxOperationCount = 500`* `OverflowPolicy = OperationOverflowPolicy.DropNew`**Behavior:*** The engine MUST maintain at most `MaxOperationCount` distinct operation entries.* When a new operation name arrives and the dictionary already has `MaxOperationCount` entries:  * With `DropNew`:    * The new operation MUST **not** be added.    * No metrics MUST be recorded for that operation.* The engine MAY log a warning the first time this occurs, and SHOULD throttle subsequent logs (e.g. at most once per minute).### 3.6 Tag Limits```csharppublic int MaxTagsPerOperation { get; set; }public int MaxTagKeyLength { get; set; }public int MaxTagValueLength { get; set; }```**Defaults:*** `MaxTagsPerOperation = 8`* `MaxTagKeyLength = 32`* `MaxTagValueLength = 64`**Behavior:*** Attempts to attach more than `MaxTagsPerOperation` tags MUST cause extra tags to be ignored.* Keys longer than `MaxTagKeyLength` MUST be truncated to that length.* Values longer than `MaxTagValueLength` MUST be truncated to that length.* Tag collections (`OperationTags`) MUST be immutable once created.---## 4. DI & Container Integration### 4.1 Primary DI: IServiceCollectionThe supported and optimized path is `Microsoft.Extensions.DependencyInjection`.Core extension:```csharppublic static class MonitoringServiceCollectionExtensions{    public static IServiceCollection AddKhaosMetrics(        this IServiceCollection services,        Action<MonitoringOptions>? configure = null);}```**Behavior:*** MUST register:  * `IOptions<MonitoringOptions>` / `IOptionsMonitor<MonitoringOptions>`  * `ISystemClock` (honoring `TimeMode`)  * The central metrics engine as a singleton  * `IOperationMonitor` as a singleton  * `IMonitoringSnapshotProvider` as a singleton  * Background timer / CPU sampler / event dispatch worker as needed### 4.2 Other Containers* The library MUST NOT directly depend on any other container abstractions.* Other DI containers MAY:  * Use `IServiceCollection` integration via adapters, or  * Manually register the concrete dependencies documented above.No separate factory/registration helpers are required beyond `AddKhaosMetrics`.---## 5. Event Sinks & Dispatch Behavior### 5.1 Event Sink Interface```csharppublic interface IOperationEventSink{    void OnOperationCompleted(OperationCompletedContext context);}````OperationCompletedContext` MUST contain:```csharppublic sealed class OperationCompletedContext{    public string Name { get; init; } = string.Empty;    public TimeSpan Duration { get; init; }    public bool IsFailure { get; init; }    public int ConcurrencyAtEnd { get; init; }    public IReadOnlyDictionary<string, string>? Tags { get; init; }    public DateTimeOffset EndTime { get; init; }          // based on TimeMode    public double? ProcessCpuPercent { get; init; }       // null if disabled}```All sink invocations MUST be wrapped in try/catch. Exceptions from sinks MUST NOT propagate into user code.### 5.2 Dispatch Mode & Queue`MonitoringOptions` MUST define:```csharppublic enum EventDispatchMode{    Inline,    BackgroundQueue}public enum EventDropPolicy{    DropNew}public EventDispatchMode EventDispatchMode { get; set; }public int EventQueueCapacity { get; set; }public EventDropPolicy EventDropPolicy { get; set; }public int EventDropLogThrottleSeconds { get; set; }```**Defaults:*** `EventDispatchMode = EventDispatchMode.BackgroundQueue`* `EventQueueCapacity = 8192`* `EventDropPolicy = EventDropPolicy.DropNew`* `EventDropLogThrottleSeconds = 60`#### 5.2.1 Inline Mode* For `EventDispatchMode.Inline`:  * `OnOperationCompleted` MUST synchronously call all registered sinks on the calling thread.  * Each sink call MUST be wrapped in try/catch.#### 5.2.2 Background Queue Mode (Default)* For `EventDispatchMode.BackgroundQueue`:  * `OnOperationCompleted` MUST:    * Build an `OperationCompletedContext`.    * Attempt to enqueue it into a bounded queue of capacity `EventQueueCapacity`.  * If the queue is full:    * With `EventDropPolicy.DropNew`:      * The event MUST be dropped and MUST NOT block the caller.      * A â€œdropped eventsâ€ counter MUST be incremented.      * A warning MAY be logged, but MUST be throttled to at most once per `EventDropLogThrottleSeconds`.  * A single (or small fixed number of) background worker(s) MUST:    * Dequeue events and call sinks synchronously (per event).    * Wrap each sink call in try/catch as above.The library MUST NEVER block application code due to event sink backpressure when using `BackgroundQueue`.---## 6. Snapshot Shape, Immutability & Serialization### 6.1 TypesSnapshots MUST be simple POCO/record types, including:* `MonitoringSnapshot`* `OperationSnapshot`* `TimeSeriesPoint`Example:```csharppublic sealed class MonitoringSnapshot{    public DateTimeOffset GeneratedAt { get; init; }    public IReadOnlyList<OperationSnapshot> Operations { get; init; }         = Array.Empty<OperationSnapshot>();}public sealed class OperationSnapshot{    public string Name { get; init; } = string.Empty;    public long TotalCount { get; init; }    public long TotalFailures { get; init; }    public double CurrentRatePerSecond { get; init; }    public TimeSpan CurrentAverageDuration { get; init; }    public TimeSpan CurrentMaxDuration { get; init; }    public IReadOnlyList<TimeSeriesPoint> PerMinute { get; init; }        = Array.Empty<TimeSeriesPoint>();    public IReadOnlyList<TimeSeriesPoint> PerHour { get; init; }        = Array.Empty<TimeSeriesPoint>();}public sealed class TimeSeriesPoint{    public DateTimeOffset Timestamp { get; init; }    public long Count { get; init; }    public TimeSpan AverageDuration { get; init; }    public TimeSpan MaxDuration { get; init; }}```### 6.2 Immutability & Thread Safety* All snapshot types MUST use read-only or init-only properties.* Once a snapshot object is returned from `IMonitoringSnapshotProvider`, it MUST NOT be mutated.* Snapshots MUST be safe to use concurrently from multiple threads (no mutable internal state).### 6.3 Serialization Requirements* No JSON attributes are required; types MUST be serializable by System.Text.Json out-of-the-box.* Naming conventions:  * Public properties in PascalCase.* Snapshots MUST NOT contain:  * Self-references  * Cycles  * Non-serializable typesThe library itself does not depend on any serializer; serialization is the responsibility of the consumer.---## 7. CPU Timing â€“ Precision & Overhead### 7.1 v1 CPU Strategy* **Per-operation CPU timing** is explicitly **out of scope** for v1.  * Any `CpuTime` per operation MUST be absent or always `null`.* CPU information in v1 is **process-level** only:  * When `EnableCpuMeasurement = true`:    * A background sampler MUST:      * Run every `CpuSampleIntervalSeconds`.      * Read `Process.GetCurrentProcess().TotalProcessorTime`.      * Compute CPU% = (delta CPU time) / (delta wall time Ã— coreCount) Ã— 100.      * Store CPU% samples in a ring buffer of length `CpuSampleHistoryCount`.* `OperationCompletedContext.ProcessCpuPercent` MUST expose the **latest** CPU% sample from this ring buffer (or `null` if not yet sampled).### 7.2 Overhead Expectations* CPU sampling occurs at most once per `CpuSampleIntervalSeconds` (default: 1 second).* Accepted overhead:  * On a typical server-class dev machine, CPU sampling MUST add less than **0.1 ms per sample** on average (this is a design target to validate via benchmarks).  * For typical workloads, CPU sampling overhead MUST be negligible compared to application workload (<1% CPU utilization at 100k operations/sec).If this target is not met in benchmarks, CPU sampling MUST be documented as more expensive, and the default `EnableCpuMeasurement` remaining `false` ensures no penalty by default.---## 8. Testing & Benchmark Criteria### 8.1 Unit Testing Requirements* **Coverage target**:  * At least **80% line coverage** for `Khaos.Metrics.Core` (excluding trivial properties/constructors).* MUST include tests for:  1. **Bucket rollover**:     * Hot, warm, cold windows roll over correctly.     * Old buckets are reset when overwritten.  2. **Aggregation correctness**:     * Averages, min, max, counts are correct given synthetic inputs.  3. **Sampling behavior**:     * `SamplingRate = 1` â†’ all calls measured.     * `SamplingRate = N` â†’ counts always correct; timings/events only on every Nth call.  4. **Overflow policy**:     * When `MaxOperationCount` is reached, new operation names do not get metrics.  5. **Tag limits**:     * Extra tags are ignored.     * Keys/values are truncated to configured lengths.  6. **Event dispatch modes**:     * Inline: sinks are called synchronously.     * BackgroundQueue: events are enqueued and processed.     * Dropping behavior when queue is full.  7. **TimeMode** behavior:     * In UTC mode, all timestamps are UTC.     * In Local mode, timestamps align with `DateTimeOffset.Now`.  8. **Concurrency**:     * Multiple threads calling `Begin/Dispose` produce consistent counts, min, max, etc. (no negative in-flight, no obvious races).### 8.2 Benchmark RequirementsUsing `BenchmarkDotNet` on a reference dev machine (document hardware in repo):Benchmarks MUST measure at least:1. `Begin/Dispose` with:   * No sinks.   * No CPU measurement.   * Expected overhead:     * **Target**: < 300 ns per call (1M operations/sec baseline scale).2. `Begin/Dispose` with:   * BackgroundQueue event sink.   * One no-op sink.   * **Target**: < 1 Âµs per call under moderate load.3. Effect of different `SamplingRate` values:   * Demonstrate overhead reduction at higher sampling rates.4. CPU sampling overhead:   * Measure process overhead with CPU measurement on vs off at a fixed operations/sec.**Acceptance:*** The library SHOULD keep overhead below ~5% of a trivial â€œempty methodâ€ at 100k ops/sec in the reference benchmark.* If not, performance characteristics MUST be documented, and default options (e.g. `SamplingRate = 1`, `EnableCpuMeasurement = false`) MUST still be safe for typical production loads (<100k ops/sec) without disproportionate overhead.---## 9. ASP.NET Integration (Explicit Opt-in)### 9.1 Hidden Base Controller`Khaos.Metrics.AspNet` MUST define:```csharppublic abstract class MonitoringControllerBase : ControllerBase{    protected MonitoringControllerBase(IMonitoringSnapshotProvider snapshots) { ... }    [NonAction]    protected ActionResult<MonitoringSnapshot> GetSnapshotCore() { ... }}```* MUST have no route attributes on the class.* Public/protected methods that return data MUST be `[NonAction]` or protected.The library MUST NOT define any concrete controllers, so ASP.NET Core will expose nothing by default.### 9.2 Minimal API Extension`Khaos.Metrics.AspNet` MUST also define:```csharppublic static class MonitoringEndpointRouteBuilderExtensions{    public static IEndpointRouteBuilder MapMonitoringEndpoints(        this IEndpointRouteBuilder endpoints,        string pattern = "/monitoring");}```This method MUST:* Create a route group with the given `pattern`.* Map endpoints (e.g., `GET /snapshot`) inside that group.* Rely on DI to obtain `IMonitoringSnapshotProvider`.No endpoints MUST be registered unless the user explicitly calls `MapMonitoringEndpoints` or creates a concrete controller deriving from `MonitoringControllerBase`.---This is now tight enough that someone can implement the library and you can verify whether they adhered to the design.If you want, we can next generate a **C# skeleton** (interfaces, options class with defaults, basic extension methods) that exactly matches this spec and is ready to drop into a new solution.

